## 前置知识

### 等比数列
`q`是等比数列的公比,计算方式是某一项除以前一项. 二叉树的公比为2.

#### 通项公式:
`a(n) = a(1)*q^(n-1)`, 用于求一棵二叉树的第x层最多可以有多少个节点:
```go
for i := 1; i < 10; i++ {
	fmt.Printf("deep: %d ,floor count: %.f\n", i, math.Pow(2.0, float64(i-1)))
}
```

#### 前n项和:
q=1时`S(n)=n*a(1)`, q > 1时: `S(n) = (a(1)*(1-q^n))/(1-q)`. 二叉树可以缩写为`S(n)= 2^n - 1`
```go
for i := 1; i < 10; i++ {
	// S(n) = (a(1)*(1-q^n))/(1-q)  
	count := math.Pow(2, float64(i)) - 1
	fmt.Printf("deep: %d count: %.f\n", i, count)
}
```




## 二分查找法
注意:
1. 边界问题；
2. int相加的溢出问题；
3. 递归的写法;
4. floor与ceil的实现


## 二分搜索树
### 概念
二分搜索树：若左子树不为空，左子树上所有节点都比根节点小；若右子树不为空，右子树上所有节点都比根节点大。

递归算法的内容有 : 1. 递归终止条件;2. 递归调用逻辑;
可以知道二叉树的定义天然递归: 1. 递归终止条件: "若左子树/右子树不为空"; 2. 递归调用逻辑: 左子树/右子树所有节点都比根节点小/大

所以二叉树的所有操作都可以用递归来实现 

### 时间复杂度
普通数组：插入：O(1)(直接读取key值) 查找删除: O(n)(需要遍历数组);
顺序数组：插入与删除: O(n)(需要遍历数组),查找: O(logn)(二分搜索)
二分搜索树: 插入、删除、查找： O(logn) (因为都是类似于二分查找)
哈希表: 插入、删除、查找：O(1)，但是哈希表没有顺序性

### 二分搜索树的优势
相对hash表，二分搜索树存在顺序性，因此可以进行一些hash表不能进行的操作:
1. 可以找到一个元素的前驱`successor`后继`predecessor`
2. 可以找到最大值`maximum`最小值`minimum`
3. 可以找到`floor(k int)`与`ceil(k int)`:floor是小于k的最大值，ceil是大于k的最小值 
4. `rank`与`select`: rank: 找到元素是排名第几的元素（需要每个节点加上属性:以这个节点为根的二分搜索1树一共有几个节点）; select:排名第x的元素是谁； 

### 二分搜索树的局限性
不平衡

### 实现思路
// todo




## 树的学习大纲:
1. 二分查找法（Binary Search）
2. 二分搜索树基础（Binary Search Tree）
3. 二分搜索树的节点插入
4. 二分搜索树的查找
5. 二分搜索树的遍历（深度优先遍历）
6. 层序遍历（广度优先遍历）
7. 删除最大值，最小值
8. 二分搜索树节点的删除（Hubbard Deletion）
9. 二分搜索树的顺序性
10. 二分搜索树的局限性
11. 二分搜索法的floor和ceil
12. 二分搜索法的lower bound和upper bound
13. 二分搜索树中的floor和ceil
14. 二分搜索树中的前驱和后继
15. 二分搜索树中的rank和select
16. 二分搜索树前中后序非递归遍历
    深入理解非递归和递归的区别，以及非递归和栈的关系
17. 二叉树前中后序遍历的经典非递归实现
18. 二叉树的Morris前中后序遍历
19. 二分搜索树整体的非递归实现
20. 二分搜索树的另一个应用：Tree Set
21. 允许重复键值的二分搜索树：Multi Tree Set / Map
22.  二叉树的公共祖先 (LCA)
23. 树形问题和回溯法
24. 树形问题之八皇后问题
25. 线段树 (区间树)
26. Trie
27. KD树
28. 哈夫曼树
29. 使用哈夫曼树进行文件压缩
30. AVL树
31. 红黑树
32. 伸展树
33. B类树
34. Treap



