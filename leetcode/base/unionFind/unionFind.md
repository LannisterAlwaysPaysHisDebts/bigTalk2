#  并查集
## 大纲
1. Quick Find
2. Quick Union
3. 基于size的优化
4. 基于rank的优化
5. 路径压缩（Path Compression）
6. 使用相同的测试用例测试不同的UF实现
7. 迭代和递归实现两种路径压缩的区别

## 笔记
并查集到底是什么 ？
> 并查集是一种树型的数据结构，用于处理一些不相交的集合的 **合并与查询** 问题

```
type UnionFind interface {
	Find(p int) (int, error)
	IsConnected(p int, q int) (bool, error)
	UnionElements(p int, q int) error
}
```


### 实现与优化
#### 版本1
是一个数组，key代表节点，value代表指向的节点（默认指向自己）。相互连接只有一层。

#### 版本2
还是个数组，key代表节点，value代表父节点（指向自己的是根节点，初始所有节点都是根节点）。几个节点相连可以组成一棵树

#### 版本3
在uf2的基础上增加了union方法的 size优化；根据两个元素所在树的元素个数不同判断合并方向，将元素个数少的集合合并到元素个数多的集合上

#### 版本4
在uf3的基础上增加了union方法的 rank优化；不是根据元素个数而是根据层数来进行判断。根据两个元素所在树的元素个数不同判断合并方向，将元素个数少的集合合并到元素个数多的集合上

#### 版本5
路径压缩

